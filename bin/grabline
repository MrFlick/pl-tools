#!/usr/bin/perl -w

=head1 NAME

grabline - a utility for displaying choosen records from a delimited text file

=head1 SYNOPSIS

grabline [--where filter] [--select columns] [--lines datalines] 
[--first] [--random number] [--sep] [--format] 
[--help] [--man] file ...

=head1 DESCRIPTION

grabline will allow you to extract and view lines from a text file.
grabline will read the column headers in the file so you can search
using column names using the C<--where> option (ie C<--where gender=M>).
Alternatively, you can also specify which data lines you want returned with
the C<--lines> option. If only one record matches your filter,
by default the record is displayed with each column value and its header
on a separate line so can you easily see what's in each column.

=head2 OPTIONS

=over 4

=item B<--where>

You must speciy your query
in the form C<field=value>. Currently only this simple filter
is supported. The field names come from the header line of the file.

=item B<--select>

A comma seperated names of the fields you wish to view from the
file. If you omit this parameter, by default all fields
are returned. Fields are returned in the order you specify
them (allow re-ordering of the columns).

=item B<--lines>

You may request certain lines to be returned from the file. The 
first row after the header is row 1. You may specify a range with
C<:> and you may select multiple, non-consecutive by separating them
with C<,>. Thus 1:3,8:10 will select rows 1,2,3,8,9, and 10.

=item B<--first>

If you set this flag, the program will stop searching after it finds
the first matching record. If used without C<--where> or C<--lines>
then grabline will simply return the first record in the file.

=item B<--random>

This option allows you select a random subset of the matching lines
from the input file. So specifying C<--random 5 --lines 1:50> will
randomly select 5 lines from the first 50 lines from the file.

=item B<--sep>

(optional) You may specify the delimiter used in
the data file. If not specified, the program will look at the
header line. If it finds a tab, it will assume that is the separator. 
If no tabs are found, it will look for commas. If no commas are found,
it will simply assume the delimiter is a space.

=item B<--format>

(optional) This allows you to sepcify how you want the output
to be formatted. You can specify C<C> for "card" format. This
breaks up the columns from the matching row into seperate lines 
where the column name is listed followed by the value in that row. You
can also specify C<L> for "line" format. This will return the data in
a tablular format with fields separated by tabs. The default is 
C<D> which will print in card format if one record is found; 
otherwise if more records are found it will use the line format.

=item B<--help>

Prints a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=back

=head2 NOTES

grabline will skip any lines at the beginning of the file that begin with "#".
You can change the comment character with the C<--comment> parameter.

Field names are case sensitive and must match exactly.

When using the default format option, grabline will wait until a second matching
record is found or the end of the file is reached before printing any
output. If you are searching a large file and are only expecting to find
a single record, you probably want to set the C<--first> option. 

You can read data from the the standard input/pipe by specifying
C<-> as the filename

=head1 EXAMPLES

Assume we have the file pheno.txt:
    #created 8/18/2008
    sampleID,gender,age
    00C01244,M,34
    04C02237,M,45
    99C18124,F,28
    
Running
    grabline --where sampleID=00C01244 pheno.txt
    
will return:
    sampleID: 00C01244
    gender: M
    age: 34

and running
    grabline --first pheno.txt
or
    grabline --lines 1 pheno.txt

will return the same thing in this case.
    
Furthermore, running
    grabline --where gender=M --select age,gender pheno.txt
    
will return
    age   gender
    34    M
    45    M

Fianlly, you can also do something like
    cat pheno.txt | tr "," "@" | grabline --where gender=F --sep="@" -

which returns
    sampleID: 99C18124
    gender: F
    age: 28

=head1 AUTHOR

Matthew Flickinger (mflick@umich.edu)

=cut

#TODO
# - allow more complex queries

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;

my $sep = "?";
my $select = "";
my $query = "";
my $rename = "";
my $lines = "";
my $firstOnly = "";
my $randomSubset = 0;
my $includeHeaderOutput = 1;
my $outformat = "D";
my ($help, $man)=(0,0);
my $commentMarker = "#";

GetOptions("sep=s" => \$sep,
    "where=s" => \$query,
    "select=s" => \$select,
	"rename=s" => \$rename,
    "lines=s" => \$lines,
    "format=s" => \$outformat,
    "first" => \$firstOnly,
	"random=i" => \$randomSubset,
	"outheader!" => \$includeHeaderOutput,
	"comment=s" => \$commentMarker,
    "help|?" => \$help, 
    "man" => \$man);

pod2usage(-verbose => 1) if $help;
pod2usage(-exitstatus => 0, -verbose=>2) if $man;
pod2usage() if @ARGV==0;

my ($matchCount, $returned, $printed) = (0, 0, 0);
my @matchCache;
my ($lineCheckRef, $maxLine) = parseLineRange($lines);
my ($totalLineCount, $totalFileCount) = (0,0);

if (@ARGV>0) {
    my @selcolheads;
    foreach my $file (@ARGV) {
        if (open(FIN, "< $file")) {
			$totalFileCount ++;
            my $header = <FIN>;
            while ($header =~ m/^$commentMarker/) {$header = <FIN>};
            if ($sep eq "?") {
                my $cnttab = ($header =~ tr/\t/\t/);
                my $cntcomma = ($header =~ tr/,/,/);
                if ($cnttab>0) {
                    $sep="\t";
                } elsif ($cntcomma>0) {
                    $sep=",";
                } else {
                    $sep=" ";
                }
            }
            my @colheads;
            if ($sep ne " ") {
                @colheads = split($sep, $header);
            } else {
                @colheads = split(" ", $header);
            }
            chomp(@colheads);
			collapseQuotes(\@colheads) if $sep eq ",";

			my ($qr, $sr, $isOk);
            ($qr, $isOk) = parseQuery($query, \@colheads);
			die("File: $file\nstopped") if !$isOk;
			($sr, $isOk) = parseSelect($select, \@colheads);
			die("File: $file\nstopped") if !$isOk;

			@selcolheads = &$sr(@colheads);
            while(<FIN>) {
				next if /^$commentMarker/;
                $totalLineCount ++;
                my @c;
                if ($sep eq ",") {
					@c = split($sep, $_);
					collapseQuotes(\@c);
				} elsif ($sep ne " ") {
                    @c = split($sep, $_, @colheads);
                } else {
                    @c = split(" ", $_, @colheads);
                }
                chomp @c;
                if( &$qr(@c)) {
                    @c = &$sr(@c);
                    $matchCount++;
                    if (&$lineCheckRef($matchCount)) {
						$returned++;
						if (!$randomSubset) {
							if ($outformat eq "L") {
								printLine(\@selcolheads) if $returned==1 and $includeHeaderOutput;
								printLine(\@c);
								$printed++;
							} elsif ($outformat eq "C") {
								if ($printed > 0) {print "-"x25, "\n";}
								printCard(\@c, \@selcolheads);
								$printed++;
							} elsif ($returned==2 && $outformat eq "D") {
								printLine(\@selcolheads) if $includeHeaderOutput;
								printLine(pop @matchCache);
								printLine(\@c);
								$printed += 2;
								$outformat="L";
							} elsif ($returned==1 && $outformat eq "D") {
								push @matchCache, [@c];
							}
						} else {
							#random subset
							if ($returned <= $randomSubset) {
								push @matchCache, [@c];
							} elsif (rand() < $randomSubset/$returned) {
								my $rep = int(rand(@matchCache));
								$matchCache[$rep] = [@c];
							}
						}
                        last if ($firstOnly and !$randomSubset) or ($maxLine>0 and $matchCount>=$maxLine);
                    }
                }
            }
            close(FIN);
            last if ($returned and $firstOnly and !$randomSubset) or ($maxLine>0 and $matchCount>=$maxLine);
        } else {
            print STDERR "Cannot open $file: $!\n";
        }
    }
	if (@matchCache>0) {
		if (@matchCache==1 && $outformat eq "D") {
			printCard($matchCache[0], \@selcolheads);
		} else {
			printLine(\@selcolheads) if $includeHeaderOutput and $outformat ne "C";
			foreach my $rowref (@matchCache) {
				if ($outformat eq "C") {
					if ($printed >= 1) {print "-"x25, "\n";}
					printCard($rowref, \@selcolheads);
				} else {
					printLine($rowref);
				}
				$printed++;
			}
		}
	}
	if ($returned==0) {
		print STDERR "No matching lines found ($totalLineCount line(s) read in $totalFileCount file(s))\n";
	}
} else {
    print STDERR "No files specified.\n";
    print STDERR "Try $0 *.txt.\n";
}

sub printCard {
    my $dataref = shift;
    my $headref = shift;
    for (my $i=0; $i < @$dataref; $i++) {
        print "$headref->[$i]: $dataref->[$i]\n";
    }
}

sub printLine {
    my $dataref = shift;
    print join("\t", @$dataref), "\n";
}

sub parseLineRange {
    my $rng = shift;
	if (!$rng) {
		return (sub {return 1}, 0);
	}
	my @lineblocks;
    foreach my $grp (split(",", $rng)) {
		if ($grp !~ m/:/) {
			push(@lineblocks, [int($grp), int($grp)]);
		} else {
			my @ss = split(":", $grp); 
			push(@lineblocks, [int($ss[0]), int($ss[1])]);
		}
    }
	@lineblocks = sort {$a->[0] cmp $b->[0]} @lineblocks;
    return (sub {
		my $line = shift;
		foreach my $r (@lineblocks) {
			last if $line < $r->[0];
			if($line >=$r->[0] and $line <=$r->[1]) {
				return 1;
				last;
			};
		}
		return 0;
	}, $lineblocks[$#lineblocks]->[1]);
}

sub parseQuery {
    my $q = shift;
    my $cr = shift;
    my %ci = map{ $cr->[$_]=> $_} (0..(scalar(@$cr)-1));
	my $isOk = 1;
    if (!$q) {
        #assume all lines match
        return sub {return 1==1;}, $isOk;
    }
    my ($fld, $val);
    for ($q) {
         ($fld, $val) = m/(.+)\s*=\s*(.+)/;
		 $val = stripMatchedQuote($val);
    }
    if (exists($ci{$fld})) {
        return sub {return $_[$ci{$fld}] eq $val}, $isOk;
    } else {
		$isOk = 0;
        print STDERR "Field [$fld] not found\n";
        printFieldNames($cr, "--where");
        return sub {return 0==1;}, $isOk;
    }
}

sub parseSelect {
    my $q = shift;
    my $cr = shift;
	my $isOk = 1;
    if (!$q) {
        return sub {return @_;}, $isOk;
    }
	my @selCols;
    my %ci = map{ $cr->[$_]=> $_} (0..(scalar(@$cr)-1));
    foreach(split(",", $q)) {
		if (exists $ci{$_}) {
			push(@selCols, $ci{$_});
		} else {
			$isOk = 0;
            print STDERR "Field [$_] not found\n";
		}
	}
    printFieldNames($cr, "--select") if !$isOk;
    return sub {return @_[@selCols]}, $isOk;
}

sub printFieldNames {
    my $cr = shift;
	my $for = shift;
    print STDERR "Valid field names ";
	print STDERR "for $for " if $for;
	print STDERR "are: [", join("][", @$cr), "]\n";
}

sub stripMatchedQuote {
	my $x = shift;
	$x =~ s/^'(.*)'$/$1/;
	$x =~ s/^"(.*)"$/$1/;
	return $x;
}

sub collapseQuotes {
	my $ar = shift;
	my $qstart=-1;
	my $qtype="";
	for(my $i=0; $i<@$ar; $i++) {
		if ($ar->[$i] =~ /^["']/ ) {
			$qstart = $i;
			$qtype = substr($ar->[$i], 0, 1);
			$ar->[$i] = substr($ar->[$i], 1);
		}
		if ($qstart>=0 && $ar->[$i] =~ /$qtype$/) {
			$ar->[$i] = substr($ar->[$i], 0, length($ar->[$i])-1);
			if ($i != $qstart) {
				splice(@$ar, $qstart, $i-$qstart+1, join(",", @$ar[$qstart..$i]));
				$i = $qstart;
			} 
			$qstart = -1;
		}
	}
}
