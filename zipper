#!/usr/bin/perl
use warnings FATAL => 'all';

=head1 NAME

zipper - matches up two sorted files based on multiple columns
(like the C<join> command but with more than one field)

=head1 SYNOPSIS

zipper --in datafile --zip zipfile [--exclude] 
    [--keys 0,1] [--inkeys 0,1] [--zipkeys 0,1] [--sep '\t']
    [--out STDOUT] [--help] [--man]

=head1 DESCRIPTION

zipper will allow you to filter the values of one file to those
that match values in another file. You can specify the fields
to use for matching. Note that files must be sorted by the fields
you use for filtering. By default, only lines matching the filter
are returned, but you can get the compliment with C<--exclude>.

=head1 AUTHOR

Matthew Flickinger (mflick@umich.edu)

=cut

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use Scalar::Util 'looks_like_number';

my $infile = "";
my $inkeys = "";
my $zipfile = "";
my $zipkeys = "";
my $mode = "lookup";
my $keys = "";
my $fields = "";
my $exclude = 0;
my $infields = "";
my $zipfields = "";
my $hasheader;
my $hasinheader;
my $haszipheader;
my $printoutheader = 1;
my $sorttype = "";
my $outfile = "-";
my $sep = "";
my $comment = "#";
my $stats = 0;
my ($help, $man) = (0,0);

GetOptions("in=s" => \$infile,
    "inkeys=s" => \$inkeys,
    "zip=s" => \$zipfile,
    "zipkeys=s" => \$zipkeys,
    "keys=s" => \$keys,
    "fields=s" => \$fields,
    "mode=s" => \$mode,
    "infields=s" => \$infields,
    "zipfields=s" => \$zipfields,
    "header!" => \$hasheader,
    "inheader!" => \$hasinheader,
    "zipheader!" => \$haszipheader,
    "outheader!" => \$printoutheader,
    "exclude" => \$exclude,
    "sort=s" => \$sorttype,
    "out=s" => \$outfile,
    "sep=s" => \$sep,
    "comment=s" => \$comment,
    "stats" => \$stats,
    "help|?" => \$help,
    "man" => \$man
);

pod2usage(-exitstatus => 0, -verbose=>2) if $man;
pod2usage(-verbose => 1) if $help || !$zipfile;

$infile = $infile || shift @ARGV || "";

cleanFileName(\$infile,\$inkeys,\$infields, $keys, $fields);
cleanFileName(\$zipfile,\$zipkeys,\$zipfields, $keys, $fields);

$hasinheader = defined($hasinheader) ? $hasinheader : 
    defined($hasheader) ? $hasheader :
    !looksLikeIndexes(split(",",$inkeys), split(",",$infields)); 
$haszipheader = defined($haszipheader) ? $haszipheader : 
    defined($hasheader) ? $hasheader :
    !looksLikeIndexes(split(",",$zipkeys), split(",",$zipfields)); 

if ($infile) {
    open(FIN, "<$infile") or die("cannot open $infile ($!), stopped");
} elsif (!(-t STDIN)) {
    open(FIN, "-");
}  else {
    pod2usage(-verbose => 1);
}

open(LIN, "<$zipfile") or die("cannot open $zipfile ($!), stopped");
open(FOUT, ">$outfile") or die("cannot open $outfile ($!), stopped");

my (@inkeys, @infields, @zipkeys, @zipfields, @innames, @zipnames);
my ($inlines, $ziplines, $inzipmatches) =(0,0,0);

if ($mode eq "sorted") {
    my @data = getNextLine(*FIN);
    my @filter = getNextLine(*LIN);

    findKeys(\@inkeys, \@zipkeys,\@data, \@filter, $inkeys, $zipkeys, $hasinheader, $haszipheader);
    findFields(\@infields, \@zipfields,\@innames, \@zipnames, \@data, \@filter, 
        $infields, $zipfields, $hasinheader, $haszipheader, \@inkeys, \@zipkeys);

    @data = getNextLine(*FIN) if $hasinheader;
    @filter = getNextLine(*LIN) if $haszipheader;

    my @sorttype = getSortType($sorttype, [@data[@inkeys]], [@filter[@zipkeys]]);

    while(@data && @filter) {
        my $comp = compFields(\@sorttype, @data[@inkeys], @filter[@zipkeys]);
        if ($comp<0) {
            print FOUT join("\t", @data), "\n" if $exclude;
            $inlines++;
            @data = getNextLine(*FIN);
        } elsif ($comp==0) {
            print FOUT join("\t", @data, @filter[@zipfields]), "\n" if !$exclude;
            $inlines++;
            @data = getNextLine(*FIN);
            #@filter = getNextLine(*LIN);
        } else {
            $ziplines++;
            @filter = getNextLine(*LIN);
        }
    }

} elsif ($mode eq "lookup") {
    my (@data, @filter);
    my %lookup;

    @data = getNextLine(*FIN);
    @filter = getNextLine(*LIN);

    findKeys(\@inkeys, \@zipkeys,\@data, \@filter, 
        $inkeys, $zipkeys, $hasinheader, $haszipheader);
    findFields(\@infields, \@zipfields,\@innames, \@zipnames, \@data, \@filter, 
        $infields, $zipfields, $hasinheader, $haszipheader, \@inkeys, \@zipkeys);

    @data = getNextLine(*FIN) if $hasinheader;
    @filter = getNextLine(*LIN) if $haszipheader;

    while( @filter ) {
        $ziplines++;
        my $key = join("\t", @filter[@zipkeys]);
        if (@zipfields) {
            $lookup{$key}  = [join("\t", @filter[@zipfields])];
        } else {
            $lookup{$key} = [];
        }
        @filter = getNextLine(*LIN);
    }

    print FOUT join("\t", @innames, @zipnames), "\n" if $printoutheader;
    while( @data ) {
        $inlines++;
        my $key = join("\t", @data[@inkeys]);
        if (exists $lookup{$key} xor $exclude ) {
            $inzipmatches++;
            my @m;
            push @m, @data[@infields] if @infields;
            push @m, @{$lookup{$key}} if exists $lookup{$key};
            print FOUT join("\t", @m), "\n";
        }
        @data = getNextLine(*FIN);
    }
} else {
    print STDERR "Unknown mode: $mode\n";
}

if($stats) {
    print "#stats {inlines:$inlines, ziplines:$ziplines, matches:$inzipmatches}\n";
}
close(FOUT);
close(LIN);
close(FIN);

sub cleanFileName {
    my $filenameRef = shift;
    my $keyRef = shift;
    my $fieldRef = shift;
    my $keys = shift;
    my $fields = shift;
    
    if ($$filenameRef =~ s/\[([^\[].*)\]$//) {
        my @c = split(";", $1, -1);
        $$keyRef = $$keyRef || $c[0] || $keys;
        $$fieldRef = $$fieldRef || $c[1] || "." if @c==2;;
    }
    $$keyRef = $$keyRef || $keys;
    $$fieldRef = $$fieldRef || ".".$fields if $fields;
}

sub findKeys {
    my ($inIdxRef, $zipIdxRef, $inRef, $zipRef, $inkeys, $zipkeys, $inheader, $zipheader) = @_;

    my (%inlookup, %ziplookup);
    %inlookup = map{$inRef->[$_]=> $_} 0..$#$inRef if $inheader;
    %ziplookup = map{$zipRef->[$_]=> $_} 0..$#$zipRef if $zipheader;

    if($inkeys eq "" and $zipkeys eq "") {
        if ($inheader && $zipheader) {
            my $overlap=0;
            for(my $i=0; $i<=$#$zipRef; $i++) {
                if ( exists($inlookup{$zipRef->[$i]}) ) {
                        $overlap++;
                        push @$inIdxRef, $inlookup{$zipRef->[$i]};
                        push @$zipIdxRef, $i;
                }
            }
            if ($overlap==0) {
                print STDERR "ERROR: No matching columns found\n";
                print STDERR "in columns: [", join("][", @$inRef), "]\n";
                print STDERR "zip columns: [", join("][", @$zipRef), "]\n";
                die ("try specifying names via --[in/zip]keys, stopped");
            }
        } else {
            die("both headers must be present to infer key columns or you must specify --keys, stopped");
        }
    } else {
        $inkeys = $inkeys || $zipkeys;
        $zipkeys = $zipkeys || $inkeys;
        push @$inIdxRef, translateKeys(\%inlookup, [split(",", $inkeys)]);
        push @$zipIdxRef, translateKeys(\%ziplookup, [split(",", $zipkeys)]);
    }
}

sub findFields {
    my ($inIdxRef, $zipIdxRef, $inNameRef, $zipNameRef, $inRef, $zipRef, $infields, $zipfields, $inheader, $zipheader, $inkeysRef, $zipkeysRef) = @_;

    my (%inlookup, %ziplookup);
    %inlookup = map{$inRef->[$_]=> $_} 0..$#$inRef if $inheader;
    %ziplookup = map{$zipRef->[$_]=> $_} 0..$#$zipRef if $zipheader;

    if ($infields eq "") {
        push @$inIdxRef, (0..$#$inRef);
    } elsif ($infields =~ s/^\.//) {
        push @$inIdxRef, translateKeys(\%inlookup, [split(",", $infields)], 0);
    } else {
        push @$inIdxRef, translateKeys(\%inlookup, [split(",", $infields)]);
    }

    my %alreadyincluded;
    foreach (@$inIdxRef) {
        if ($inheader && $zipheader) {
            $alreadyincluded{ $ziplookup{ $inRef->[$_] } }=1 if exists $ziplookup{ $inRef->[$_] };
        } else {
            my $ai = arrayIndex($_, @$inkeysRef);
            if ($ai > -1) {
                    $alreadyincluded{$zipkeysRef->[$ai]} = 1;
            }
        }
    }

    if ($zipfields eq "") { 
        for (my $i=0; $i<@$zipRef; $i++) {
            push (@$zipIdxRef, $i) if !exists($alreadyincluded{$i});
        }
    } else  {
        my @f;
        if ($zipfields =~ s/^\.//) {
            @f = translateKeys(\%ziplookup, [split(",", $zipfields)], 0);
        } else {
            @f = translateKeys(\%ziplookup, [split(",", $zipfields)]);
        }
        foreach (@f) {
            push (@$zipIdxRef, $_) if !exists($alreadyincluded{$_});
        }
    }

    if ($inheader) {
        push (@$inNameRef, map{$inRef->[$_]} @$inIdxRef);
    } else {
        push (@$inNameRef, map{"IN".($_+1)} @$inIdxRef);
    }
    if ($zipheader) {
        push (@$zipNameRef, map{$zipRef->[$_]} @$zipIdxRef);
    } else {
        push (@$zipNameRef, map{"ZIP".($_+1)} @$zipIdxRef);
    }
}

sub translateKeys {
    my $idxRef = shift;
    my $keysRef = shift;
    my $failonnotfound = shift;
    $failonnotfound = 1 if !defined $failonnotfound;

    my @b;

    for(my $i=0; $i<=$#$keysRef; $i++) {
        if(exists($idxRef->{$keysRef->[$i]})) {
            push @b,  $idxRef->{$keysRef->[$i]};
        } elsif ($keysRef->[$i] =~ m/^\d+\z/i && $keysRef->[$i]>0 && 
                (!(keys %$idxRef) || $keysRef->[$i] < keys %$idxRef)) {
            push @b, $keysRef->[$i]-1;
        } elsif($failonnotfound) {
            print STDERR "unable to parse \"", join(",",@$keysRef), "\"";
            print STDERR "; \"$keysRef->[$i]\" could not be translated\n";
            print STDERR "known column names: [", join("][", keys %$idxRef), "]\n", if keys %$idxRef;
            die("stopped");
        }
    }

    return @b;
}

sub looksLikeIndexes {
    my $ret=0;
    sub isposint {no warnings;return $_[0] eq ($_[0]+0) && $_[0] == int($_[0]) && $_[0]>0}
    foreach my $a (@_) {
        if(ref($a) eq "ARRAY") {
            for my $b (@$a) {
               if (!isposint($b)) {return 0};
                $ret = 1;
            }
        } else {
            if (!isposint($a)) {return 0};
            $ret = 1;
        }
    }
    return $ret;
}

sub getSortType {
    my ($sorttype, $dataRef, $filterRef) = @_;
    my @sorttype;
    if ($sorttype) {
        @sorttype = split(",", lc $sorttype);
        die("sorted count (". @sorttype . 
            ") does not match key count (".@$dataRef.")") if @sorttype != @$dataRef;
    } else {
        for(my $i=0; $i<@{$dataRef}; $i++) {
            if (looks_like_number($dataRef->[$i]) &&
                looks_like_number($filterRef->[$i])) {
                push @sorttype, "n";
            } else {
                push @sorttype, "c";
            }
        }
    }
    return @sorttype;
}

sub getNextLine {
    my $fh = shift;
    my $line = <$fh>;
    while($line && $line =~ /^$comment/) {$line = <$fh>;}
    if ($line) {
        chomp($line);
        if (!$sep) {
            return split(" ", $line);
        } else {
            return split($sep, $line);
        }
    } else {
        return split("","");
    }
}

sub compFields {
    my $sorttypeRef = shift @_;
    my @fields = @_;
    my $fc = scalar(@fields)/2;
    for (my $i=0; $i<$fc; $i++) {
        if (@$sorttypeRef && $sorttypeRef->[$i] eq "n") {
            if($fields[$i] != $fields[$i+$fc]) {
                return $fields[$i] <=> $fields[$i+$fc];
            }
        } else {
            if($fields[$i] ne $fields[$i+$fc]) {
                return $fields[$i] cmp $fields[$i+$fc];
            }
        }
    }
}

sub arrayIndex(@)
{        
     1 while $_[0] ne pop; $#_;
}
