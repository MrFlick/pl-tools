#!/usr/bin/perl

=head1 NAME

zipper - matches up two sorted files based on multiple columns
(like the C<join> command but with more than one field)

=head1 SYNOPSIS

zipper --in datafile --zip zipfile [--exclude] 
    [--keys 0,1] [--inkeys 0,1] [--zipkeys 0,1] [--sep '\t']
    {--out STDOUT] [--help] [--man]

=head1 DESCRIPTION

zipper will allow you to filter the values of one file to those
that match values in another file. You can specify the fields
to use for matching. Note that files must be sorted by the fields
you use for filtering. By default, only lines matching the filter
are returned, but you can get the compliment with C<--exclude>.

=head1 AUTHOR

Matthew Flickinger (mflick@umich.edu)

=cut

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;

my $infile = "";
my $inkeys = "";
my $zipfile = "";
my $zipkeys = "";
my $keys = "0,1";
my $exclude = 0;
my $mergefields = "";
my $skiplines = "0";
my $outfile = "-";
my $sep = "\t";
my ($help, $man) = (0,0);

GetOptions("in=s" => \$infile,
    "inkeys=s" => \$inkeys,
    "zip=s" => \$zipfile,
    "zipfields=s" => \$zipkeys,
    "keys=s" => \$keys,
    "merge=s" => \$mergefields,
    "skip=s" => \$skiplines,
    "exclude" => \$exclude,
    "out=s" => \$outfile,
    "sep=s" => \$sep,
    "help|?" => \$help,
    "man" => \$man
);

pod2usage(-exitstatus => 0, -verbose=>2) if $man;
pod2usage(-verbose => 1) if $help || !$infile || !$zipfile;

my @inkeys = split(",", $inkeys || $keys);
my @zipkeys = split(",", $zipkeys || $keys);
my @mergefields = split(",", $mergefields);

die("field counts must match in:"
    .join(",",@inkeys)." filter:"
    .join(",", @zipkeys).", stopped") if @inkeys != @zipkeys;
my ($skipin, $skipzip) = split(",",$skiplines);
$skipzip = $skipzip || $skipin;

open(FIN, "<$infile") or die("cannot open $infile ($!), stopped");
for(my $i=0; $i<$skipin; $i++) {<FIN>;}
open(LIN, "<$zipfile") or die("cannot open $zipfile ($!), stopped");
for(my $i=0; $i<$skipzip; $i++) {<LIN>;}
open(FOUT, ">$outfile") or die("cannot open $outfile ($!), stopped");

my @data = getNextLine(*FIN);
my @filter = getNextLine(*LIN);

while(@data && @filter) {
    my $comp = compFields(@data[@inkeys], @filter[@zipkeys]);
    if ($comp<0) {
        print FOUT join("\t", @data), "\n" if $exclude;
        @data = getNextLine(*FIN);
    } elsif ($comp==0) {
        print FOUT join("\t", @data, @filter[@mergefields]), "\n" if !$exclude;
        @data = getNextLine(*FIN);
        @filter = getNextLine(*LIN);
    } else {
        @filter = getNextLine(*LIN);
    }
}


close(FOUT);
close(LIN);
close(FIN);

sub getNextLine {
    my $fh = shift;
    my $line = <$fh>;
    if ($line) {
        chomp($line);
        return split($sep, $line);
    } else {
        return split("","");
    }
}

sub compFields {
    my @fields = @_;
    my $fc = scalar(@fields)/2;
    for (my $i=0; $i<$fc; $i++) {
        if($fields[$i] != $fields[$i+$fc]) {
            return $fields[$i] <=> $fields[$i+$fc];
        } 
    }
}
